% resultados
Neste capítulo apresentaremos os resultados obtidos pelos modelos
descritos no Capítulo~\ref{cap:model}. A Seção \ref{sec:tspec} mostra
as características do computador utilizado para executar os testes. A
Seção \ref{sec:testes} descreve como os testes foram executados. A
Seção \ref{sec:analise} apresenta a análise dos resultados obtidos
durante este trabalho.

\section{Especificações Técnicas}
\label{sec:tspec}
O computador utilizado para executar os testes possui as seguintes
características:

\begin{itemize}
  \item{Processador: Intel\textregistered{}~Core\texttrademark~2 Duo
  2.33GHz.}

  \item{Memória RAM: 3 GB.}
  
  \item{Sistema Operacional: Ubuntu Linux com kernel 2.6.31.}

  \item{Compilador para linguagem C++: gcc 4.4.3~\cite{gcc*2012}.}

\end{itemize}

Todos modelos de \pr{} foram implementados usando as seguintes
ferramentas:

\begin{itemize}
  \item{Sistema de programação de código
  aberto \textit{ECLiPSe-6.0}~\cite{eclipse*2009}, usando a linguagem
  própria, baseada no prolog.}
  
 \item{O código foi escrito na linguagem C++, usando o pacote
  proprietário \textit{IBM\textregistered{} ILOG\textregistered{}
  CPLEX\textregistered{} CP Optimizer v 2.3}~\cite{ilogcp*2011}.}
\end{itemize}

Todas formulações de programação linear inteira foram implementadas
usando as seguintes ferramentas:

\begin{itemize}
  \item{Sistema de programação de código
  aberto \textit{GLPK-4.35}~\cite{glpk*2010}, usando a linguagem de
  modelagem \textit{GNU MathProg}.}
  
  \item{O código foi escrito na linguagem C++, usando o pacote
  proprietário \textit{IBM\textregistered{} ILOG\textregistered{}
  CPLEX\textregistered{} Optimizer v 12.1}~\cite{ilogcplex*2011}.}
\end{itemize}

\section{Descrição dos Testes}
\label{sec:testes}
Os testes foram separados de acordo com o tamanho das permutações. Uma
instância contém um conjunto de permutações com tamanho $n$, onde $n >
2$ devido ao fato de ser trivial ordenar uma permutação com tamanho
$2$. Para cada instância, geramos $50$ permutações aleatórias com
tamanho $n$.

Todas instâncias foram executadas nos softwares indicados na
Seção \ref{sec:tspec}. Para cada instância foi dado o tempo máximo de
$25$ horas. Fazemos a comparação dos modelos baseando nos tempos
médios usados para resolver cada instância. Como referência usamos os
modelos de \pli{} descritos na Seção \ref{sec:pli}.

\section{Análise dos Resultados}
\label{sec:analise}
As tabelas \ref{table:rev}, \ref{table:trans}, \ref{table:r_t}
apresentam os tempos médios usados para resolver cada instância dos
testes. O caractere ``-'' significa que o modelo não conseguiu
solucionar todas as permutações da instância dentro do limite de 25
horas. O caractere ``*'' significa que o modelo não conseguiu terminar
devido ao limite de memória do sistema.

Podemos observar nos três casos que os modelos de programação por
restrições baseados na teoria COP possuem os piores tempos de execução
e os modelos baseados na teoria CSP possuem os melhores resultados.

O modelo baseado na teoria COP tem como objetivo otimizar o resultado
do problema. Seu mecanismo de busca consiste em encontrar uma solução
base para depois encontrar uma solução melhor, usando um valor melhor
para a função de custo. Com isso, ele acaba gerando um espaço de busca
maior do que o modelo correspondente baseado na teoria CSP, que usa
uma estratégia \textit{bottom-up}.

Também podemos notar que, quanto melhor os limitantes, menor é o tempo
necessário para solucionar as instâncias, conseguindo resolver mais
instâncias com permutações ``maiores''\footnote{Nenhum modelo
conseguiu resolver instâncias com permutações de tamanho $n > 14$,
dentro do tempo limite de $25$ horas.}. Isto ocorre pela redução do
conjunto das possíveis soluções do problema.

A seguir faremos a análise separadamente para cada caso. A
Seção \ref{subsec:analise_rev} contém os resultados para o problema de
ordenação por reversões. A Seção \ref{subsec:analise_tra} contém os
resultados para o problema de ordenação por transposições. A
Seção \ref{subsec:analise_r_t} contém os resultados para o problema de
ordenação por reversões e transposições. A
Seção \ref{subsec:analise_ferramentas} apresenta a comparação das
ferramentas utilizadas nos testes.

\subsection{Ordenação por Reversões}
\label{subsec:analise_rev}
Nos modelos de ordenação por reversões, Tabela \ref{table:rev},
podemos notar que alguns modelos não conseguiram solucionar as
permutações devido ao limite de memória do sistema. Isto ocorreu com
as permutações de tamanho $n = 10$ usando os três limitantes nos
modelos baseados na teoria CSP desenvolvido para o \textit{ILOG CP},
com as permutações de tamanho $n = 13$ para o
limitante \textit{rev\_cg\_csp} no modelo baseado na teoria CSP e com
as permutações de tamanho $n = 6$ para o
limitante \textit{rev\_cg\_cop} no modelo baseado na teoria COP
desenvolvidos para o \textit{ECLiPSe}.

No \textit{ECLiPSe}, é possível observar que nos modelos baseados na
teoria COP, quanto melhor o limitante, maior é o tempo necessário para
resolver as instâncias. O principal motivo é a complexidade existente
para encontrar os melhores limitantes, juntamente com o aumento do
espaço de busca gerado pelo modelo COP. 

A diferença na complexidade pode ser observada quando comparamos os
resultados de ordenação por reversões com os resultados de ordenação
por transposições, Tabela \ref{table:trans}. É possível notar que, nos
resultados dos limitantes triviais, coluna \textbf{def}, e dos no
grafo de \bkp{} para reversões.limitantes que usam \bkp{},
colunas \textit{rev\_br} e \textit{tra\_br}, o tempo dos modelos de
ordenação por reversão é melhor, em relação aos modelos de
transposição. Isto ocorre, devido à procura dos blocos na permutação,
que irá sofrer o evento escolhido. A reversão irá alterar apenas um
bloco, ou seja, necessita apenas escolher duas posições na
permutação. No caso da transposição, o evento trocará dois blocos
adjacentes de lugar, necessitando escolher três posições na
permutação. Logo o espaço de busca dos modelos de ordenação por
transposição é maior do que o espaço dos modelos de ordenação por
reversões.

Entretanto, se focarmos apenas nos melhores limitantes dos dois tipos
de ordenação, colunas \textit{rev\_cg} e \textit{tra\_cg}, ocorre
justamente o inverso. Este comportamente pode ser explicado usando a
decomposição em ciclos. Na transposição a decomposição é única, para
todo vértice do grafo de ciclos, toda aresta chegando é únicamente
pareada com uma aresta saindo de cor diferente, então basta encontrar
o número de ciclos ímpares. No caso da reversão, todo vértice possui o
mesmo número de arestas incidentes cinzas e pretas no grafo
de \bkp{}. Logo existem diversas maneiras para realizar a decomposição
em ciclos. Como o modelo usa os limitantes definidos por
Christie~\cite{Christie*1998}, é necessário mais processamento
para encontrar a decomposição máxima em $2$-ciclos, aumentando o
espaço de busca dos modelos de ordenação por reversões.

A diferença na complexidade pode ser notado, também, nos modelos
baseados na teoria CSP desenvolvidos para o \textit{ILOG CP}. Isto
pode ser causado por dois motivos:
\begin{enumerate}

  \item{Forma da modelagem: Como o modelo foi pensado para
  o \textit{ECLiPSe}, o modelo não aproveita características
  específicas do \textit{ILOG CP} que poderiam melhorar sua
  performance.}

  \item{Mecanismo de \textit{backtracking}\footnote{Algoritmo para
  encontrar soluções para um problema computacional. Ele pode eliminar
  múltiplas soluções apenas se decidir que elas não são viáveis para o
  problema.}: O \textit{ECLiPSe} usa uma linguagem baseada no prolog,
  que possui o paradigma de programação lógica. Uma das suas
  características é ter o mecanismo de \textit{backtracking} embutido
  na linguagem. No caso do \textit{ILOG CP}, o modelo foi escrito
  usando a linguagem C++, que é uma linguagem orientada à objetos, não
  tem o mecanismo de \textit{backtracking} por padrão. Portanto, para
  o \textit{ECLiPSe} realizar o \textit{backtracking} é ``mais
  natural'' em relação ao \textit{ILOG CP}.}

\end{enumerate}

Nenhum modelo de ordenação por reversões conseguiu solucionar as
instâncias com permutações de tamanho $n > 13$ dentro do tempo limite
de $25$ horas.

\input{tables/rev.tex}

\subsection{Ordenação por Transposições}
\label{subsec:analise_tra}
Nos modelos de ordenação por transposições, Tabela \ref{table:trans},
os modelos baseados na teoria COP que usam o
limitante \textit{tra\_br\_cop} apresentaram os piores resultados,
apresentando nenhuma vantagem em relação ao modelo que usa limitantes
triviais \textit{def\_cop}.

No \textit{ECLiPSe}, é possível observar que, diferentemente do modelo
de ordenação por reversões, nos modelos baseados na teoria COP, o
melhor limitante, \textit{tra\_cg\_cop}, obteve o melhor tempo de
execução. Este limitante conseguiu reduzir o espaço de busca por ser
mais preciso que os outros. Neste caso, a redução do espaço de busca
supriu a necessidade da quantidade de processamento para encontrar o
número de ciclos ímpares no grafo de ciclos da ordenação por
transposições, ao contrário do modelo de ordenação por reversões que
usa o limitante \textit{rev\_cg}.

Similar ao modelo de ordenação por reversões, nos modelos baseados na
teoria CSP desenvolvidos para o \textit{ILOG CP}, quanto melhor o
limitante, maior é o tempo necessário para resolver as instâncias.

Nenhum modelo de ordenação por transposições conseguiu solucionar as
instâncias com permutações de tamanho $n > 14$ dentro do tempo limite
de $25$ horas.

\input{tables/trans.tex}

\subsection{Ordenação por Reversões e Transposições}
\label{subsec:analise_r_t}
Os modelos de ordenação por reversões e transposições,
Tabela \ref{table:r_t}, obtiveram os piores resultados. Isto já era
esperado, devido ao fato que os modelos utilizam tanto a operação de
reversão como a operação de transposição, resultando em um espaço de
busca maior e no aumento do tempo necessário para encontrar a solução.

O modelo baseado na teoria CSP que usa o
limitante \textit{r\_t\_cc\_csp} desenvolvido para o \textit{ECLiPSe}
não conseguiu resolver a instância com permutações de tamanho $n = 7$
devido ao limite de memória do sistema. Foi o único modelo de
ordenação por reversões e transposições que ocorreu este problema.

É possível notar claramente o rápido crescimento do espaço de busca
dos modelos conforme o tamanho das permutações. Como exemplo, podemos
pegar os modelos baseados na teoria CSP desenvolvidos para
o \textit{ILOG CP}. O modelo que obteve o pior tempo para a instância
com permutações de tamanho $n = 10$ foi o modelo \textit{def\_csp},
que não utiliza limitantes, e o seu tempo de execução para essa
instância foi de $0.012$ segundos. Um tempo excelente para o modelo
que, diferentemente dos modelos que utilizam as operações
isoladamente, conseguiu solucionar esta instância. Porém para as
instâncias com permutações de tamanho $n > 10$, os modelos não
conseguiram solucionar todas permutações dentro do limite de tempo.

Nenhum modelo de ordenação por reversões e transposições conseguiu
solucionar as instâncias com permutações de tamanho $n > 10$ dentro do
tempo limite de $25$ horas.

\input{tables/r_t.tex}

\subsection{Comparação das ferramentas}
\label{subsec:analise_ferramentas}
Um dos objetivos deste trabalho é analisar se os softwares
proprietários são inferiores ou superiores aos softwares de código
aberto.

No caso das formulações em programação linear inteira, podemos notar
que as formulações desenvolvidas para o \textit{ILOG CPLEX} obtiveram
os melhores tempos para as instâncias com permutações de tamanho
$n \le 7$, mas para permutações com $n > 7$ as formulações
desenvolvidas para o \textit{GLPK} foram mais rápidas, com exceção da
instância com permutações de tamanho $n = 9$ que o \textit{GLPK} não
conseguiu solucionar dentro do tempo limite, ao contrário
do \textit{ILOG CPLEX}. Se analisamos somente a quantia de instâncias
resolvidas, podemos afirmar que \textit{ILOG CPLEX} é o mais adequado
para os problemas de ordenação, devido ao fato de resolver uma
instância a mais em relação ao \textit{GLPK}. Mas se analisamos os
tempos de execução, o \textit{ILOG CPLEX} ganha somente nos modelos de
ordenação por reversões, perdendo para o \textit{GLPK} nos modelos de
ordenação por transposições e ordenação por reversões e transposições.

No caso dos modelos de programação por restrições, podemos notar que
os modelos baseados na teoria COP, nos três casos, o \textit{ILOG CP}
foi superior ao \textit{ECLiPSe}, tanto nos tempos de execução, quanto
na quantia de instâncias resolvidas. Para os modelos baseados na teria
COP, podemos afirmar que o \textit{ILOG CP} é o mais adequado para os
problemas de ordenação.

Mas para os modelos baseados na teoria CSP, o \textit{ECLiPSe} não só
obteve tempos melhores, mas também resolveu instâncias maiores, exceto
nos modelos de ordenação por reversões e transposições. Então, para o
modelo de ordenação por reversões e transposições, o \textit{ILOG CP}
é o mais adequado, mas para os outros modelos, podemos afirmar que
o \textit{ECLiPSe} é o mais adequado.
