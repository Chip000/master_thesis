Neste capítulo nós apresentaremos a descrição dos modelos de \pr{} e
\pli{} usados para os problemas de ordenação por transposições,
ordenação por reversões e ordenação por reversões e transposições.

\section{\PR}
\label{sec:cp}
O modelo de \pr{} usado para o problema de ordenação por transposições
é o descrito em Dias e Dias \cite{DiasDias*2009}. Nós usamos os
limitantes inferior e superior descritos em (REFERENCIAR) para
escrever as formulações baseadas nas teorias de Problema de Satisfação
de Restrições (CSP) e Problema de Otimização com Restrições (COP). As
formulações foram descritas usando a notação prolog-like de
Marriot \cite{Marriott*1998}. Primeiramente iremos apresentar os
predicados que são comum às duas formulações.

Em prolog as variáveis são descritas por \textit{strings} iniciadas
com letra maiúscula ou ``\_'' (\textit{underscore}) caso a variável
seja anônima. As letras gregas $\pi$ e $\sigma$ representam listas
nesta notação. A construção $X~::~[i~..~j]$ significa que $X$ (ou cada
elemento de $X$ se $X$ for uma lista) pode assumir um valor do
intervalo $[i~..~j]$.

A representação da permutação (\ref{perm}) e o efeito das operações de
reversão (\ref{reversal}) e transposição (\ref{transposition} podem
ser vistas da mesma maneira que são descritas pelos problemas. Neste
modelo a permutação $\pi$ é uma lista de elementos
($\pi_{1},~\pi_{2},~\ldots~,~\pi_{n}$) onde $\pi_{i} \in \mathbb{N}$,
$0 < \pi_{i} \le n$ e $\pi_{i} \neq \pi_{j}$ para $i \neq j$.
\begin{align}
  \label{perm}
  \textit{per}&\textit{mutation}(\pi, N)~\text{:-} \nonumber\\
  &\textit{length}(\pi, N), \\ 
  &\pi~::~[1~..~N], \nonumber\\
  &\textit{all\_different}(\pi). \nonumber
\end{align}

Na reversão $\rho(i,j)$, $0 < i < j \leq n$, dividimos a lista em três
sublistas $C_{1}C_{2}C_{3}$ onde $C_{1} = (\pi_{1}~..~\pi_{i-1})$,
$C_{2} = (\pi_{i}~..~\pi_{j})$ e $C_{3} =
(\pi_{j+1}~..~\pi_{n})$. Depois fazemos a reversão na sublista
$C_{2}$, resultando na lista $R_{C_{2}}$. Então juntamos a nova lista
$R_{C_{2}}$ com as sublistas $C_{1}$ e $C_{3}$ para formar $\rho\pi =
C_{1}R_{C_{2}}C_{3}$.
\begin{align}
  \label{reversal}
  \textit{rev}&\textit{ersal}(\pi, \sigma, I, J)~\text{:-} \nonumber\\
  &\textit{permutation}(\pi, N), \nonumber\\
  &\textit{permutation}(\sigma, N), \nonumber \\
  &1 \le I < J \le N, \\
  &\textit{split}(\pi, I, J, C_{1}, C_{2}, C_{3}), \nonumber\\
  &\textit{reverse}(C_{2}, R_{C_{2}}), \nonumber \\
  &\sigma = C_{1}, R_{C_{2}}, C_{3}. \nonumber
\end{align}

Na transposição $\rho(i,j,k)$, $0 < i < j < k\leq n$, dividimos a
lista em quatro sublistas $C_{1}C_{2}C_{3}C_{4}$ onde $C_{1} =
(\pi_{1}~..~\pi_{i-1})$, $C_{2} = (\pi_{i}~..~\pi_{j-1})$, $C_{3} =
(\pi_{j}~..~\pi_{k-1})$ e $C_{4} = (\pi_{k}~..~\pi_{n})$. Trocamos de
posição os blocos $C_{2}$ e $C_{3}$ e juntamos elas na ordem $C_{1}$,
$C_{3}$, $C_{2}$ e $C_{4}$ para formar $\rho\pi =
C_{1}C_{3}C_{2}C_{4}$. Observe que as sublistas $C_{1}$ e $C_{4}$
podem ser vazias.
\begin{align}
  \label{transposition}
  \textit{tra}&\textit{nsposition}(\pi, \sigma, I, J, K)~\text{:-} \nonumber\\
  &\textit{permutation}(\pi, N), \nonumber\\
  &\textit{permutation}(\sigma, N), \\
  &1 \le I < J < K \le N, \nonumber \\
  &\textit{split}(\pi, I, J, K, C_{1}, C_{2}, C_{3}, C_{4}), \nonumber\\
  &\sigma = C_{1}, C_{3}, C_{2}, C_{4}. \nonumber
\end{align}

\subsection{Modelo CSP}
\label{subsec:modelcsp}
Primeiramente modelaremos o problema usando a teoria CSP, mas o número
de variáveis é desconhecido devido ao fato de precisarmos do valor da
distância $d_{r}(\pi)$ para criar as restrições e variáveis que
representam as permutações. Por esta razão, nós escolhemos um valor
candidato para a distância $R$ tal que $R \in [LB~..~UB]$, onde $LB$ é
um limitante inferior conhecido e $UB$ é um limitante superior
conhecido para o problema, e tentamos achar a combinação apropriada de
$R$ reversões que solucionam o problema. Se o modelo CSP falha (não
existe combinação que soluciona o problema com o valor candidato
escolhido) com o candidato $R$, nós escolhemos outro valor $R$ apenas
incrementando seu valor. O valor de $R$ é escolhido usando uma
estratégia \textit{bottom-up}\footnote{EXPLICAR BOTTOM-UP} e por
definição não verificamos nenhum valor maior que o limitante superior
$UB$. Na transposição, o processo é o mesmo que na reversão, trocando
apenas o valor da distância de reversão ($d_{r}(\pi)$) para o valor da
distância de transposição ($d_{t}(\pi)$).
\begin{align}
  \label{revdistance}
  \textit{rev}&\textit{ersal\_distance}(\iota, 0, \_Model). \nonumber\\
  \textit{rev}&\textit{ersal\_distance}(\pi, R, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &R :: [LB .. UB], \\
  &\textit{indomain}(R), \nonumber \\
  &\textit{reversal}(\pi, \sigma, \_I, \_J), \nonumber \\
  &\textit{reversal\_distance}(\sigma, R-1, Model). \nonumber
\end{align}
\begin{align}
  \label{tradistance}
  \textit{tra}&\textit{nsposition\_distance}(\iota, 0, \_Model). \nonumber\\
  \textit{tra}&\textit{nsposition\_distance}(\pi, T, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &T :: [LB .. UB], \\
  &\textit{indomain}(T), \nonumber \\
  &\textit{transposition}(\pi, \sigma, \_I, \_J, \_K), \nonumber \\
  &\textit{transposition\_distance}(\sigma, T-1, Model). \nonumber
\end{align}

O predicado \textit{rev\_trans\_dist/3} (\ref{trarevdist}) retorna o
valor da distância de reversão e transposição. O
predicado \textit{event/2} escolhe o melhor evento entre o
predicado \textit{reversal/4} (\ref{reversal}) e o
predicado \textit{transposition/5} (\ref{transposition}) para
minimizar o valor da distância.
\begin{align}
  \label{trarevdist}
  \textit{rev}&\textit{\_trans\_dist}(\iota, 0, \_Model). \nonumber\\
  \textit{rev}&\textit{\_trans\_dist}(\pi, N, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &N :: [LB .. UB], \\
  &\textit{indomain}(N), \nonumber \\
  &\textit{event}(\pi, \sigma), \nonumber \\
  &\textit{rev\_trans\_dist}(\sigma, N-1, Model). \nonumber
\end{align}

O predicado \textit{indomain(X)} em (\ref{revdistance}),
(\ref{tradistance}) e (\ref{trarevdist}) pega o domínio da variável
$X$ e escolhe o menor elemento dele (no caso o valor do limitante
inferior). Se o modelo retorna para o predicado \textit{indomain}
devido a uma falha, o elemento que originou ela será removido do
domínio e um outro valor será escolhido.

Os modelos CSP para os problemas possuem a estrutura mostrada acima,
trocando apenas os limitantes usados. Em comum a todas operações temos
o modelo \textit{def\_csp} que não usa nenhum limitante.

\textit{Ordenação por reversões:}
\begin{itemize}
\item{\textit{rev\_br\_csp}: 
Modelo que usa o conceito de \bkp{} em reversões para calcular os
limitantes conforme descrito ..... (REFERENCIA)}
\item{\textit{rev\_cg\_csp}:
Modelo que usa o conceito de decomposição de 2-ciclos no grafo de
ciclos em reversões para calcular os limitantes conforme descrito
.... (REFERENCIA)}
\end{itemize}

\textit{Ordenação por transposições:}
\begin{itemize}
\item{\textit{tra\_br\_csp}: 
Modelo que usa o conceito de \bkp{} em transposições para calcular os
limitantes conforme descrito .... (REFERENCIA)}
\item{\textit{tra\_cg\_csp}:
Modelo que usa o conceito de grafo de ciclos em transposições, fazendo
a decomposição de ciclos e analisando os ciclos ímpares separadamente
para calcular os limitantes conforme descrito .... (REFERENCIA)}
\end{itemize}

\textit{Ordenação por reversões e transposições:} 
\begin{itemize}
\item{\textit{r\_t\_br\_csp}: 
Melhor limitante superior entre o limitante de \bkp{} para reversões e
o limitante de \bkp{} para transposições.}
\item{\textit{r\_t\_bc\_csp}:
Melhor limitante superior entre o limitante de \bkp{} para reversões e
o limitante do grafo de ciclos para transposições.}
\item{\textit{r\_t\_cc\_csp}: 
Melhor limitante superior entre o limitante do grafo de ciclos para
reversões e o limitante do grafo de ciclos para transposições.}
\end{itemize}

O predicado \textit{bound/4} (\ref{bound}) recebe na
variável \textit{Model} um átomo que representa o modelo a ser
usado. Este átomo se conecta com o predicado que retorna o limitante
superior e inferior apropriado para o modelo. Observe que o limitante
inferior é igual a $0$ no caso dos modelos de ordenação por reversões
e transposições. Isto ocorre devido ao fato que a cada nova iteração
do modelo pode surgir um limitante inferior melhor, simplesmente
fazendo a troca entre as operações de reversão e transposição.
\begin{align}
  \label{bound}
  \textit{bou}&\textit{nd}(\pi, def\_csp, LB, UB)~\text{:-} \nonumber\\
  &\textit{def\_csp\_bound}(\pi, LB, UB). \nonumber \\
  \textit{bou}&\textit{nd}(\pi, rev\_br\_csp, LB, UB)~\text{:-} \nonumber \\
  &\textit{calc\_breakpoints\_reversal}(\pi, B), \nonumber\\
  &LB = B / 2 \nonumber \\ % / 2 ,  \\
  &UB = B. \nonumber \\
  \textit{bou}&\textit{nd}(\pi, rev\_cg\_csp, LB, UB)~\text{:-} \nonumber \\
  &\textit{find\_2\_cycle}(\pi, B, C), \nonumber\\
  &LB = (2 * B - C) / 3 , \nonumber  \\
  &UB = B - C / 2. \nonumber \\
  \textit{bou}&\textit{nd}(\pi, tra\_br\_csp, LB, UB)~\text{:-} \nonumber\\
  &\textit{calc\_breakpoints\_transposition}(\pi, B), \nonumber\\
  &LB = B / 3 \nonumber \\ %/ 3, \nonumber \\
  &UB = B.  \nonumber \\
  \textit{bou}&\textit{nd}(\pi, tra\_br\_csp, LB, UB)~\text{:-} \\
  &\textit{calc\_oddcycle\_transposition}(\pi, N, C), \nonumber\\
  &LB = (N + 1 - C) / 2 \nonumber \\ 
  &UB = (3 * (N + 1 - C)) / 4. \nonumber \\
  \textit{bou}&\textit{nd}(\pi, r\_t\_br\_csp, 0, UB)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, rev\_br, \_RLB, RUB), \nonumber\\
  &\textit{bound}(\pi, tra\_br, \_TLB, TUB), \nonumber\\
  &\textit{min}(RUB, TUB, UB), \nonumber\\
  \textit{bou}&\textit{nd}(\pi, r\_t\_bc\_csp, 0, UB)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, rev\_br, \_RLB, RUB), \nonumber\\
  &\textit{bound}(\pi, tra\_cg, \_TLB, TUB), \nonumber\\
  &\textit{min}(RUB, TUB, UB), \nonumber\\
  \textit{bou}&\textit{nd}(\pi, r\_t\_cc\_csp, 0, UB)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, rev\_cg, \_RLB, RUB), \nonumber\\
  &\textit{bound}(\pi, tra\_cg, \_TLB, TUB), \nonumber\\
  &\textit{min}(RUB, TUB, UB), \nonumber
\end{align}

\subsection{Modelo COP}
\label{subsec:modelcop}
Uma outra alternativa é modelar o problema usando a teoria COP. Os
modelos que usam esta abordagem necessitam de um limitante superior,
portanto serão feitas algumas alterações nos predicados definidos
anteriormente. Nós usamos as variáveis binárias $B$ para indicar
quando uma operação de reversão ou de transposição modificou ou não a
permutação fornecida.

O primeiro predicado que precisamos criar é o \textit{reversal\_cop/5}
(\ref{reversal_cop}). Primeiramente, dado uma reversão $\rho(i, j)$,
adicionamos uma nova restrição para permitir $(i, j) = (0, 0)$. Se
$(i, j) = (0, 0)$ então $\pi\rho = \pi$. Então, adicionamos um novo
argumento ao predicado \textit{reversal\_cop} que recebe a variável
$B$.
\begin{align}
  \label{reversal_cop}
  \textit{rev}&\textit{ersal\_cop}(\iota, \iota, 0, 0, 0). \\
  \textit{rev}&\textit{ersal\_cop}(\pi, \sigma, I, J, 1)~\text{:-}~ 
  \textit{reversal}(\pi, \sigma, I, J). \nonumber
\end{align}

O predicado equivalente para transposição é
o \textit{transposition\_cop/6} (\ref{transposition_cop}). Neste caso,
dado uma transposição $\rho(i, j, k)$, adicionamos uma nova restrição
para permitir $(i, j, k) = (0, 0, 0)$. Se $(i, j, k) = (0, 0, 0)$
então $\pi\rho = \pi$.
\begin{align}
  \label{transposition_cop}
  \textit{tra}&\textit{nsposition\_cop}(\iota, \iota, 0, 0, 0, 0). \\
  \textit{tra}&\textit{nsposition\_cop}(\pi, \sigma, I, J, K, 1)~\text{:-}~ 
  \textit{transposition}(\pi, \sigma, I, J, K). \nonumber
\end{align}

Para calcular a distância nos modelos baseados na teoria COP,
implementamos o predicado \textit{reversal\_distance\_cop/3}
(\ref{revdistance_cop}), que ajusta as variáveis $B$ usando o valor do
limitante superior e restringe as permutações fazendo $\pi_{k}
= \pi_{k-1} \rho_{k}$. O predicado \textit{length/2}, predicado
interno do prolog, é usado para criar uma lista de variáveis não
instanciadas com o tamanho dado. A função de custo \textit{Cost} é a
soma das variáveis $B$ associadas com cada $\rho_{k}$, $Cost
= \sum_{k=1}^{UB} B_{k}$, onde $UB$ é um limitante superior
conhecido. A distância de reversão é o valor mínimo da função de custo
$d_{r} = \min Cost$. Para evitar processamento desnecessários, o valor
de $Cost$ precisa ser maior ou igual a qualquer limitante inferior. O
predicado equivalente para transposição é
o \textit{transposition\_distance\_cop/3} (\ref{tradistance_cop}).
\begin{align}
  \label{revdistance_cop}
  \textit{rev}&\textit{ersal\_distance\_cop}(\pi, R, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &\textit{length}(B, UB), \nonumber \\
  &\textit{upperbound\_constraint\_rev}(\pi, B, Model, UB), \\
  &\textit{sum}(B, Cost), \nonumber \\
  &\textit{Cost} \ge \textit{LB}, \nonumber \\
  &\textit{minimize}(Cost, R). \nonumber
\end{align}
\begin{align}
  \label{tradistance_cop}
  \textit{tra}&\textit{nsposition\_distance\_cop}(\pi, T, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &\textit{length}(B, UB), \nonumber \\
  &\textit{upperbound\_constraint\_trans}(\pi, B, Model, UB), \\
  &\textit{sum}(B, Cost), \nonumber \\
  &\textit{Cost} \ge \textit{LB}, \nonumber \\
  &\textit{minimize}(Cost, T). \nonumber
\end{align}

O predicado equivalente para o modelo de ordenação por reversões e
transposições é
o \textit{rev\_trans\_dist\_cop/3}~(\ref{trarevdistcop}). O
predicado \textit{upperbound\_constraint\_event/4} escolhe o melhor
evento entre a reversão, usando o
predicado \textit{upperbound\_constraint\_rev/4}
(\ref{ub_constaint_rev}), e a transposição, usando o
predicado \textit{upperbound\_constraint\_trans/4}
(\ref{ub_constaint_tra}), para minimizar o valor da distância.
\begin{align}
  \label{trarevdistcop}
  \textit{rev}&\textit{\_trans\_dist\_cop}(\pi, N, Model)~\text{:-} \nonumber\\
  &\textit{bound}(\pi, Model, LB, UB), \nonumber\\
  &\textit{length}(B, UB), \nonumber \\
  &\textit{upperbound\_constraint\_event}(\pi, B, Model, UB), \\
  &\textit{sum}(B, Cost), \nonumber \\
  &\textit{Cost} \ge \textit{LB}, \nonumber \\
  &\textit{minimize}(Cost, N). \nonumber
\end{align}

O predicado \textit{upperbound\_constraint\_rev/4}
(\ref{ub_constaint_rev}) aplica na permutação os efeitos de $\rho_{k}$
e retorna o valor apropriado de $B$ para cada reversão $\rho_{k}$. Uma
restrição importante é verificar se é possível ordenar a permutação
usando o número restante de reversões para evitar processamento
desnecessário. O predicado equivalente para a transposição é o
\textit{upperbound\_constraint\_trans/4} (\ref{ub_constaint_tra}).
\begin{align}
  \label{ub_constaint_rev}
  \textit{upp}&\textit{erbound\_constraint\_rev}(\iota, [~], \_Model, \_UB). \nonumber\\
  \textit{upp}&\textit{erbound\_constraint\_rev}(\pi, [B|Bt], Model, UB)~\text{:-} \nonumber\\
  &\textit{reversal\_cop}(\pi, \sigma, \_I, \_J, B), \\
  &\textit{bound}(\pi, Model, LB, \_UB), \nonumber\\
  &UB \ge LB, \nonumber \\
  &\textit{upperbound\_constraint\_rev}(\sigma, Bt, Model, UB - 1), \nonumber 
\end{align}
\begin{align}
  \label{ub_constaint_tra}
  \textit{upp}&\textit{erbound\_constraint\_trans}(\iota, [~], \_Model, \_UB). \nonumber\\
  \textit{upp}&\textit{erbound\_constraint\_trans}(\pi, [B|Bt], Model, UB)~\text{:-} \nonumber\\
  &\textit{transposition\_cop}(\pi, \sigma, \_I, \_J, \_K, B), \\
  &\textit{bound}(\pi, Model, LB, \_UB), \nonumber\\
  &UB \ge LB, \nonumber \\
  &\textit{upperbound\_constraint\_trans}(\sigma, Bt, Model, UB - 1), \nonumber 
\end{align}

Os modelos baseados na teoria COP possuem a estrutura acima, trocando
apenas os limitantes usados. Os limitantes são os mesmos usados para
os modelos CSP, modificados para os modelos COP. Então temos os
seguintes limitantes: \textit{def\_cop}, \textit{rev\_br\_cop},
\textit{rev\_cg\_cop}, \textit{tra\_br\_cop}, \textit{tra\_cg\_cop}, 
\textit{r\_t\_br\_cop}, \textit{r\_t\_bc\_cop}
e \textit{r\_t\_cc\_cop}.

\section{\PLI}
\label{sec:cp}
